<!DOCTYPE html>
<html lang="zh-ch">
<head>
    
        
<meta charset="utf-8">
<meta name="HandheldFriendly" content="True">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer-when-downgrade">

<title>Memory Modules and Namespaces  - To be a sailor</title>
<meta name="description" content="books review, life, messy thinking">

<link rel="icon" type="image/x-icon" href="https://binghuacheng.github.io/favicon.ico">
<link rel="apple-touch-icon-precomposed" href="https://binghuacheng.github.io/favicon.png">

<link rel="stylesheet" href="https://binghuacheng.github.io/css/style.css?rnd=1589975421" />



<meta property="og:title" content="Memory Modules and Namespaces" />
<meta property="og:description" content="Main Content  Separate compilation of programs Storage duration, scope, and linkage Placement new Namespaces  Separate Compilation In general, We divide the program into three parts:
 A header file that contains the structure declarations and prototypes for functions that use those structures A source code file that contains the code for the structure-related functions A source code file that contains the code that calls the structure-related functions  Here are some things commonly found in header files:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://binghuacheng.github.io/posts/memory-modules-and-namespaces/" />
<meta property="article:published_time" content="2020-05-16T05:50:08+00:00" />
<meta property="article:modified_time" content="2020-05-16T05:50:08+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Memory Modules and Namespaces"/>
<meta name="twitter:description" content="Main Content  Separate compilation of programs Storage duration, scope, and linkage Placement new Namespaces  Separate Compilation In general, We divide the program into three parts:
 A header file that contains the structure declarations and prototypes for functions that use those structures A source code file that contains the code for the structure-related functions A source code file that contains the code that calls the structure-related functions  Here are some things commonly found in header files:"/>






    
</head>
<body>
    <a class="skip-main" href="#main">Skip to main content</a>
    <div class="container">
        <header> 
            
                <h1 class="site-header">
    <a href="https://binghuacheng.github.io">To be a sailor</a>
</h1>
<nav>
    
    
    <a class="" href="/about/" title="">About</a>
    
    <a class="" href="/tags/" title="">Tags</a>
    
    <a class="" href="/posts/" title="">Archive</a>
    
</nav>

            
        </header>
        <main id="main" tabindex="-1"> 
            

    <article class="post">
        <header>
            <h1>Memory Modules and Namespaces</h1>
        </header>
        <div class="content">
            <h2 id="main-content">Main Content</h2>
<ul>
<li>Separate compilation of programs</li>
<li>Storage duration, scope, and linkage</li>
<li>Placement <code>new</code></li>
<li>Namespaces</li>
</ul>
<h2 id="separate-compilation">Separate Compilation</h2>
<p>In general, We divide the program into three parts:</p>
<ul>
<li>A header file that contains the structure declarations and prototypes for functions that use those structures</li>
<li>A source code file that contains the code for the structure-related functions</li>
<li>A source code file that contains the code that calls the structure-related functions</li>
</ul>
<p>Here are some things commonly found in header files:</p>
<ul>
<li>Function prototypes</li>
<li>Symbolic constants defined using <code>#define</code> or <code>const</code></li>
<li>Structure declarations</li>
<li>Class declarations</li>
<li>Template declarations</li>
<li>Inline function</li>
</ul>
<h2 id="storage-duration-scope-and-linkage">Storage Duration, Scope, and Linkage</h2>
<p>C++ uses four separate schemes for sorting data, and the scheme differ in how long they preserve data in memory:</p>
<ul>
<li>Automatic storage duration</li>
<li>Static storage duration</li>
<li>Thread storage duration(C++11)</li>
<li>Dynamic storage duration</li>
</ul>
<h3 id="specifiers-and-qualifiers">Specifiers and Qualifiers</h3>
<p>Certain C++ keywords, called <code>storage class specifier</code> and <code>cv-qualifiers</code>, provided  additional information about storage.</p>
<h4 id="cv-qualifiers">Cv-Qualifiers</h4>
<p>Here are the cv-qualifiers:</p>
<ul>
<li>const</li>
<li>volatile</li>
</ul>
<p>The <code>volatile</code> keyword indicates that the value in a memory location can be altered even though nothing in the program code modifies the contents. The intent of this keyword is to improve the optimization abilities of compiler. For example, suppose the compiler notices that a program uses the value of a particular variable twice within a few statementss. Rather than have the program look up the value twice, the compiler might cache the value in a register. This optimization assumes that the value of the variable doesn&rsquo;t change between the two uses. If you don&rsquo;t define a variable as <code>volatile</code>, then the compiler can feel free to make this optimization. If you do declare a variable as <code>volatile</code>, you&rsquo;re telling the compiler not to make that sort of optimization.</p>
<h4 id="mutable">mutable</h4>
<p>You can use it to indicate that a particular member of a structure(or class) can be altered even if a particular structure(or class) variable is a <code>const</code>. For example,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">data</span>
{
	<span style="color:#66d9ef">char</span> name[<span style="color:#ae81ff">30</span>];
	<span style="color:#66d9ef">mutable</span> <span style="color:#66d9ef">int</span> accesses;
	...
};
<span style="color:#66d9ef">const</span> data veep <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#34;Claybourne Clodde&#34;</span>, <span style="color:#ae81ff">0</span>, ...};
strcpy(veep.name, <span style="color:#e6db74">&#34;Joye Joux&#34;</span>);
veep.accesses<span style="color:#f92672">++</span>;
</code></pre></div><h4 id="about-const">About <code>const</code></h4>
<p>In c++(but not C), the <code>const</code> modifier alters the default storage classes slightly. Whereas a global variable has external linkage by default, a <code>const</code> global variable has internal linkage by default.
If, for some reason, you want to make a constant have external linkage, you can use the <code>external</code> keyword to override the default internal linkage:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">external <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> states<span style="color:#f92672">=</span><span style="color:#ae81ff">50</span>;	<span style="color:#75715e">// definition with external linkage
</span></code></pre></div><p>When you declare a <code>const</code> within a function or block, it has block scope, which means the constant is usable only when the program is executing code within the block. This means that you can create constant within a function or block and not have to worry about the names conflicting with constants defined elsewhere.</p>
<h3 id="function-and-linkageone-definition-rule">Function and Linkage(One definition rule)</h3>
<p>C++, like C, doesn&rsquo;t allow you to define one function inside another, so all function automatically have static storage duration, meaning they are all present as long as the program is running. By default, functions have external linkage, meaning they can be shared across files. You can, in fact, use the keyword <code>extern</code> in a function prototype to indicate that the function is defined in another file, but that&rsquo;s optional. You can also use the keyword <code>static</code> to give a function internal linkage, confining its use to a single file. You would apply this keyword to the <code>prototype</code> and the <code>function definition</code>.</p>
<p><strong>Note:</strong> where C++ find functions</p>
<p>Suppose you call a function in a particular program. Where does C++ look for the function definition? If the function prototype in that file indicates that the file is static, the compiler looks only in that file for the function definition. Otherwise, the compiler(and the linker, too) look in all the program files. If it finds two definition, the compiler sends you a error message because you can have only one definition for one external function. If it fails to find any definition in the files, the function then searches the libraries. This implies that if you define a function that has the same name as a library function, the compiler uses you version rather than the library version.(However, C++ reserves the names of the standard library functions, so you shound&rsquo;t reuse them.) Some compiler-linker need explicit instructions to identify which library to search.</p>
<h2 id="storages-schemes-and-dynamic-allocation">Storages Schemes and Dynamic Allocation</h2>
<p>The dynamic memory can be allocated from one function and freed from another function. Unlike automatic memory, dynamic memory is not <code>LIFO</code>; the order of allocation and freeing depends on when and how <code>new</code> and <code>delete</code> are used.</p>
<h3 id="new-operators-functions-and-replacement-function"><code>new</code>: Operators, Functions, and Replacement Function</h3>
<p>The <code>new</code> and <code>new[]</code> operators call upon two functions:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(std<span style="color:#f92672">::</span>size_t);	<span style="color:#75715e">//used by new
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>[](std<span style="color:#f92672">::</span>size_t);	<span style="color:#75715e">//used by new[]
</span></code></pre></div><p>These are termed <code>allocation function</code>, and they are part of the global namespace. Similarly, there are deallocation functions used by <code>delete</code> and <code>delete[]</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>);		<span style="color:#75715e">// used by new
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>[](std<span style="color:#f92672">::</span>size_t);	<span style="color:#75715e">// used by new[]
</span></code></pre></div><p>Here the <code>std::size_t</code> is <code>typedef</code> for some suitable integer type.
A basic statement such as</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span> pi <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>;
</code></pre></div><p>gets translated into something like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span> pi <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</code></pre></div><p>And the statement</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span> pa <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">40</span>];
</code></pre></div><p>gets translated into something like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span> pa<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span>(<span style="color:#ae81ff">40</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</code></pre></div><p>In general, using the <code>new</code> operator may do more than just call the <code>new()</code> function.</p>
<h3 id="the-placement-new-operator">The Placement <code>new</code> Operator</h3>
<p>The <code>new</code> operator has a variation, called <code>placement new</code>, that allows you to specify the location to be used. You can use thid feature to set up your own memory-management procedures or to deal with hardware that is accessed via a particular address or to construct objects in a particular memory location.
To use the placement <code>new</code> feature, you first include the <code>new</code> header file, which provides a prototype for this version of <code>new</code>. The following code fragment shows the syntax for using these four forms of <code>new</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;new&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">chaff</span>
{
	<span style="color:#66d9ef">char</span> dross[<span style="color:#ae81ff">20</span>];
	<span style="color:#66d9ef">int</span> slag;
};
<span style="color:#66d9ef">char</span> buffer1[<span style="color:#ae81ff">50</span>];
<span style="color:#66d9ef">char</span> buffer2[<span style="color:#ae81ff">500</span>];
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	chaff <span style="color:#f92672">*</span>p1, <span style="color:#f92672">*</span>p2;
	<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p3, <span style="color:#f92672">*</span>p4;
	<span style="color:#75715e">// first, the regular forms of new
</span><span style="color:#75715e"></span>	p1<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> chaff;	<span style="color:#75715e">// place structure in heap
</span><span style="color:#75715e"></span>	p3<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">20</span>];	<span style="color:#75715e">// place int array in heap
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// now, thw two forms of placement new
</span><span style="color:#75715e"></span>	p2<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> (buffer1) chaff;	<span style="color:#75715e">// place structure in buffer1
</span><span style="color:#75715e"></span>	p4<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> (buffer2) <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">20</span>];	<span style="color:#75715e">//place int array in buffer2
</span><span style="color:#75715e"></span>	...
}
</code></pre></div><h3 id="other-forms-of-placement-new">Other Forms of Placement <code>new</code></h3>
<p>Just as regular ``new<code>invokes a new function with one argument, the standard placement</code>new``` invokes a new function with two arguments:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span> p1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>;	<span style="color:#75715e">// invokes new(sizeof(int))
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span> p2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> (buffer) <span style="color:#66d9ef">int</span>;	<span style="color:#75715e">// invokes new(sizeof(int), buffer)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span> p3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> (buffer) <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">40</span>];	<span style="color:#75715e">// invokes new(40*sizeof(int), buffer)
</span></code></pre></div><h2 id="namespaces">Namespaces</h2>
<h3 id="traditional-c-namespaces">Traditional C++ Namespaces</h3>
<p>One term you need to be aware of is <code>declarative region</code>. A declaratice region is a region in which declaration can be made. For example, you can declare a global variable outside any function. The declarative region for that variable is the file in which it is declared. If you declare a variable inside a function , its declarative region is the innermost block in which it is declared.
A second term you need to be aware of is <code>potential scope</code>. The potential scope for a variable begins at its point of declaration and extends to the end of its declarative region.
The portion of the program that can actually see the the variable is termed the <code>scope</code>.</p>
<h3 id="new-namespace-features">New Namespace Features</h3>
<p>The following code, for example, uses the keyword <code>namespace</code> to craete two namespaces, <code>Jack</code> and <code>Jill</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">namespace</span> Jack {
	<span style="color:#66d9ef">double</span> pail;	<span style="color:#75715e">// variable declaration
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fetch</span>();	<span style="color:#75715e">// function prototype
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> pal;	<span style="color:#75715e">// variable declaration
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Well</span> {...};	<span style="color:#75715e">// structe declaration
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">namespace</span> Jill {
	<span style="color:#66d9ef">double</span> <span style="color:#a6e22e">bucket</span>(<span style="color:#66d9ef">double</span> n) {...}	<span style="color:#75715e">//function definition
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">double</span> fetch;		<span style="color:#75715e">// variable declaration
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> pal;	<span style="color:#75715e">// variable declaration
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Hill</span> {...};	<span style="color:#75715e">// structure declaration
</span><span style="color:#75715e"></span>}
</code></pre></div><p>Namespaces can be located at the global level or inside other namespace, but they cannot be placed in a block. Thus, a name declared in a namespace has external linkage by default(unless it refers to a <code>constant</code>).</p>
<p>Namepsace are <code>open</code>, meaning that they can add names to existing namespaces. for example, the following statement adds the name <code>goose</code> to the existing list of names in <code>Jill</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">namespace</span> Jill {
	<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">goose</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>);
}
</code></pre></div><p>Of course, you need a way to access names in a given namespace. The simplest way is to use ::, the scope-resolution operator, to <code>qualify</code>(限定，修饰） a name with its namespace:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">Jack<span style="color:#f92672">::</span>pail<span style="color:#f92672">=</span><span style="color:#ae81ff">12.34</span>;	<span style="color:#75715e">// use a variable
</span><span style="color:#75715e"></span>Jill<span style="color:#f92672">::</span>Hill<span style="color:#f92672">=</span>mole; 	<span style="color:#75715e">// create a type Hill structure
</span><span style="color:#75715e"></span>Jack<span style="color:#f92672">::</span>fetch();		<span style="color:#75715e">//use a function
</span></code></pre></div><p>An unadorned name, such as <code>pail</code>, is termed the <code>unqualified name</code>, whereas a name with the namespace, as in <code>Jack::pail</code>, is termed a <code>qualified name</code>.</p>
<h3 id="using-declarations-and-using-directives"><code>using</code> Declarations and <code>using</code> Directives</h3>
<p>C++ provides two mechanisms &ndash; the <code>using declaration</code> and the <code>using directive</code> &ndash; to simplify using namespace names. The <code>using</code> declaration lets you make particular identifier available, and the <code>using directive</code> makes the entire namespace accessible. for instance:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">using</span> Jill<span style="color:#f92672">::</span>fetch<span style="color:#960050;background-color:#1e0010">\</span>;	<span style="color:#75715e">// a using declaration
</span></code></pre></div><h3 id="using-directives-versus-using-declarations"><code>using</code> Directives Versus <code>using</code> Declarations</h3>
<p>If a particular name is alreday declared in a function, you can&rsquo;t import the same name with a <code>using declaration</code>. However, if you use a <code>using  directiv</code>e to import a name that is already declared in a function, the local name will hide the namespace name, just as it would hide a global variable of the same name. But you can still use the scope-resolution operators, as in the following example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">namespace</span> Jill {
	<span style="color:#66d9ef">double</span> <span style="color:#a6e22e">bucket</span>(<span style="color:#66d9ef">double</span> n) { }
	<span style="color:#66d9ef">double</span> fetch;
	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Hill</span> { ... };
}

<span style="color:#66d9ef">char</span> fetch;	<span style="color:#75715e">// global namespace
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> Jill;	<span style="color:#75715e">// import all namespace names
</span><span style="color:#75715e"></span>	Hill Thrill;		<span style="color:#75715e">// create a type Jill::Hill structure
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">double</span> water<span style="color:#f92672">=</span>bucket(<span style="color:#ae81ff">2</span>);	<span style="color:#75715e">// use Jill::bucket();
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">double</span> fetch;		<span style="color:#75715e">// not an error; hides Jill::fetch
</span><span style="color:#75715e"></span>	cin <span style="color:#f92672">&gt;&gt;</span> fetch;		<span style="color:#75715e">// read a value into the local fetch
</span><span style="color:#75715e"></span>	cin <span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">::</span>fetch;		<span style="color:#75715e">// read a value into global fetch
</span><span style="color:#75715e"></span>	cin <span style="color:#f92672">&gt;&gt;</span> Jill<span style="color:#f92672">::</span>fetch;	<span style="color:#75715e">// read a value into Jill::fetch
</span><span style="color:#75715e"></span>	...
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">foom</span>()
{
	Hill top;	<span style="color:#75715e">// ERROR
</span><span style="color:#75715e"></span>	Jill<span style="color:#f92672">::</span>Hill crest;	<span style="color:#75715e">// valid
</span><span style="color:#75715e"></span>}
</code></pre></div><p><strong>Note:</strong></p>
<p>Generally speaking, the <code>using</code> declaration is safer to use than a <code>using</code> directive because it shows exactly what names you are making available . And if the name conflict with a local name, the compiler lets you know. The <code>using</code> directive adds all names, even one you might not need. If a local name conflicts, it overrides the namespace version, and you aren&rsquo;t warned. Also, the open nature of namespaces means that the complete list of names in a namespace might be spread over several locations, making it difficult to know exactly which name you are adding.</p>
<h3 id="more-namespace-feature">More Namespace Feature</h3>
<p>You can nest namespace declarations, like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">namespace</span> elements
{
	<span style="color:#66d9ef">namespace</span> fire
	{
		<span style="color:#66d9ef">int</span> flame;
		...
	}
	<span style="color:#66d9ef">float</span> water;
}
</code></pre></div><p>In this case, you can refer to the flame variable as elements::fire::flame. Similarly, you can make the inner names available with this <code>using</code> directive:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> element<span style="color:#f92672">::</span>fire;
</code></pre></div><p>Also, you can use <code>using</code> directive and <code>using</code> declarations inside namespaces, like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">namespace</span> myth
{
	<span style="color:#66d9ef">using</span> Jill<span style="color:#f92672">::</span>fetch;
	<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> elements;
	<span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>cout;
	<span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>cin;
}
</code></pre></div><p>Now consider applying a <code>using</code> directive to the <code>myth</code> namespace. The <code>using</code> directive is <code>transtive</code>. In this context, the upshot is that the following statement places both the <code>myth</code> and <code>elements</code> namespaces in scope:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> myth;
</code></pre></div><p>This single directive has the same effect as the following two directives:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> myth;
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> elements;
</code></pre></div><p>You can create an alias for a namespace. For example, suppose you have a namespace defined as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">namespace</span> my_very_favorite_things { ... };
<span style="color:#66d9ef">namespace</span> mvft<span style="color:#f92672">=</span>my_very_favorite_things;
</code></pre></div><p>You can use this technique to simplify using nested namespaces:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">namespace</span> MEF<span style="color:#f92672">=</span>myth<span style="color:#f92672">::</span>element<span style="color:#f92672">::</span>fire;
<span style="color:#66d9ef">using</span> MEF<span style="color:#f92672">::</span>flame;
</code></pre></div><h3 id="unnamed-namespaces">Unnamed Namespaces</h3>
<p>You can create an <code>unnamed namespace</code> by omiting the namespace name:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">namespace</span>	<span style="color:#75715e">// unnamed namespace
</span><span style="color:#75715e"></span>{
	<span style="color:#66d9ef">int</span> ice;
	<span style="color:#66d9ef">int</span> bandcoot;
}
</code></pre></div><p>Names in an unnamed namespace are like global variables. This provides an alternative to using static variables with internal linkage.</p>
<h3 id="namespaces-and-the-future">Namespaces and the Future</h3>
<p>Here are some programming idioms:</p>
<ul>
<li>Use variables in a named namespace instead of using external global variables.</li>
<li>Use variable in an unnamed namespace instead of using static global variable.</li>
<li>If you develop a library of functions or classes, place them in a namespace. Instead, C++ currently already calls for placing standard library function in a namespace called <code>std</code>. This extends to functions brought in from C. For example, the <code>math.c</code> header file, which is C-compatible, doesn&rsquo;t use namespaces, but the C++ <code>cmath</code> header file should place the various math library functions in the <code>std</code> namespace.</li>
<li>Use the <code>using</code> directive only as a tempolary means of converting old code to namespace usage.</li>
<li>Don&rsquo;t use <code>using</code> directives in header files; for one thing, doing so conceals which names are being made available. Also, the ordering of header files may affect behavior. If you use a <code>using</code> directive, place it after all the preprocessor <code>#include</code> directive.</li>
<li>Preferentially import names by using the scope-resolution operator or a <code>using</code> declaration.</li>
<li>Preferentially use local scope instead of global scope for <code>using</code> declarations.</li>
</ul>
<h2 id="summary">Summary</h2>
<p>C++ encourages the use of multiple files in developing programs. An effective organization strategy is to use a header file to define user types and provide function prototype for functions to manipulate the user type. You should use a separate source code file for the fnction definitions. Together, the header file and the source file define and implement the user-defined type and how it can be used. Then, <code>main()</code> and other functions using those functions can go into a third file.
C++'s storage schemes determine how long variables remain in memory(storage duration) and what parts of a program have access to them(scope and linkage). Automatic variables are variables that are defined within a block, such as a function body or a block within the body. They exist and are known only while the program executes statements in the block that contains the definition. Automatic variable may be declared by using the storage class specifier <code>register</code> or with no specifier at all, in which case the variable is automatically automatic. The <code>register</code> specifier was a hint to the compiler that the variable is heavily used, but that use is deprecated(反对) under C++11.</p>

        </div>
        <div class="article-info">
    
        <div class="article-date">2020-05-16</div>
    
    <div class="article-taxonomies">
        
            
                <ul class="article-tags">
                    
                        <li><a href="https://binghuacheng.github.io/tags/c&#43;&#43;-primer-plus">#C&#43;&#43;-Primer-Plus</a></li>
                    
                        <li><a href="https://binghuacheng.github.io/tags/c&#43;&#43;">#C&#43;&#43;</a></li>
                    
                </ul>
        
    </div>
</div>

    </article>
    


        </main>
        <footer>
            
                <p>© binghuacheng, 2020<br>
Powered by <a target="_blank" href="https://gohugo.io/">Hugo</a>, theme <a target="_blank" href="https://github.com/mitrichius/hugo-theme-anubis">Anubis</a>.
</p>
            
        </footer>
    </div>
</body>
</html>
