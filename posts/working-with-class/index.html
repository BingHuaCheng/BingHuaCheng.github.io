<!DOCTYPE html>
<html lang="zh-ch">
<head>
    
        
<meta charset="utf-8">
<meta name="HandheldFriendly" content="True">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer-when-downgrade">

<title>Working With Class  - To be a sailor</title>
<meta name="description" content="books review, life, messy thinking">

<link rel="icon" type="image/x-icon" href="https://binghuacheng.github.io/favicon.ico">
<link rel="apple-touch-icon-precomposed" href="https://binghuacheng.github.io/favicon.png">

<link rel="stylesheet" href="https://binghuacheng.github.io/css/style.css?rnd=1590802775" />



<meta property="og:title" content="Working With Class" />
<meta property="og:description" content="Main Content  Operator overloading Friend function Overloading the &laquo; operator for output State members Using rand() to generate random values Automatic conversions and type casts for classes Class conversion functions  Operator Overloading Operator overloading is an example of C&#43;&#43; polymorphism. Operator overloading extends the overloading concept to operators, letting you assign multiple meanings to C&#43;&#43; operators. To overload an operator, you use a special function form called an operator function." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://binghuacheng.github.io/posts/working-with-class/" />
<meta property="article:published_time" content="2020-05-19T02:28:26+00:00" />
<meta property="article:modified_time" content="2020-05-19T02:28:26+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Working With Class"/>
<meta name="twitter:description" content="Main Content  Operator overloading Friend function Overloading the &laquo; operator for output State members Using rand() to generate random values Automatic conversions and type casts for classes Class conversion functions  Operator Overloading Operator overloading is an example of C&#43;&#43; polymorphism. Operator overloading extends the overloading concept to operators, letting you assign multiple meanings to C&#43;&#43; operators. To overload an operator, you use a special function form called an operator function."/>






    
</head>
<body>
    <a class="skip-main" href="#main">Skip to main content</a>
    <div class="container">
        <header> 
            
                <h1 class="site-header">
    <a href="https://binghuacheng.github.io">To be a sailor</a>
</h1>
<nav>
    
    
    <a class="" href="/about/" title="">About</a>
    
    <a class="" href="/tags/" title="">Tags</a>
    
    <a class="" href="/posts/" title="">Archive</a>
    
</nav>

            
        </header>
        <main id="main" tabindex="-1"> 
            

    <article class="post">
        <header>
            <h1>Working With Class</h1>
        </header>
        <div class="content">
            <h2 id="main-content">Main Content</h2>
<ul>
<li>Operator overloading</li>
<li>Friend function</li>
<li>Overloading the &laquo; operator for output</li>
<li>State members</li>
<li>Using <code>rand()</code> to generate random values</li>
<li>Automatic conversions and type casts for classes</li>
<li>Class conversion functions</li>
</ul>
<h2 id="operator-overloading">Operator Overloading</h2>
<p><code>Operator overloading</code> is an example of C++ polymorphism. Operator overloading extends the overloading concept to operators, letting you assign multiple meanings to C++ operators.
To overload an operator, you use a special function form called an <code>operator function</code>. An operator function has the following form, where <code>op</code> is the symbol for the operator being overloaded:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">operatorop(argument<span style="color:#f92672">-</span>list)
</code></pre></div><p>For example, <code>operator+()</code> overloads the <code>+</code> operator and <code>opeartor*()</code> overloads the <code>*</code> operator. The <code>op</code> has to be a valid C++ operator; you can&rsquo;t just make up a new symbol.</p>
<p>Suppose, for example, that you have a <code>Salesperson</code> class for which you define an <code>operator+()</code> member function to overload the <code>+</code> operator so that it adds sales figures of one salesperson object to another. Then, if <code>district2</code>, <code>sid</code>, and <code>sare</code> are all object of the <code>salesperson</code> class, you can write this equation:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">district2<span style="color:#f92672">=</span>sid<span style="color:#f92672">+</span>sare;
</code></pre></div><p>The compiler, recognizing the operands as belonging to the <code>salesperson</code> class, replaces the operator with the corresponding operator function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">district2<span style="color:#f92672">=</span>sid.<span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(sara);
</code></pre></div><h2 id="developing-an-operator-overloading-example">Developing an Operator Overloading Example</h2>
<p><em><strong>Caution:</strong></em></p>
<p>Don&rsquo;t return a reference to a local variable or another temporary object. When the function terminates and the local variable or temporary object disappears, the reference becomes a reference to non-exist data.</p>
<h3 id="overloading-restrictions">Overloading Restrictions</h3>
<p>Overloaded operators(with some exceptions) don&rsquo;t necessarily have to be member functions. However, there are some limits C++ imposes on user-defined operator overloading:</p>
<ul>
<li>The overloaded operator must have at least one operand that is user-defined type.</li>
<li>You can&rsquo;t use an operator in a manner that violates the syntax rules for the original operator. For example, you can&rsquo;t overload the modules operator(%) so that it can be used with a single operand. Similarly, you can&rsquo;t alter operator precedence. So if you overload the addition operator to let you add two classes, the new operator has the same precedence as ordinary addition.</li>
<li>You can&rsquo;t create new operator symbols. For example, you can&rsquo;t define an <code>operator**()</code> function to denote exponentiation.</li>
<li>You cannot overload the following operators:</li>
</ul>
<pre><code>|Operator	|Description			|
|.....		|.......			|
|sizeof		|the sizeof operator		|
|.		|the membership operator	|
|.*		|the pointer-to-member operator	|
|::		|the scope-resolution operator	|
|?:		|the conditional operator	|
|typeid		|An RTTI operator		|
|const_cast	|A type cast operator		|
|dynamic_cast	|A type cast operator		|
|reinterpret	|A type cast operator		|
|static_cast	|A type cast operator		|
</code></pre><ul>
<li>Most of the operators in Table11.1 can be overloaded by using either member or nonmemberfunctions. However, you can use <code>only</code> member function to overload the following operators:</li>
</ul>
<pre><code>|Operator		|Description				|
|........		|........				|
|	=		|Assignment operator			|
|	()		|Function call operator			|
|	[]		|Subscripting operator			|
|	-&gt;		|Class member access by pointer operator|
</code></pre><p><em><strong>Table 11.1</strong></em> Operator that can be overloaded</p>
<pre><code>+	-	*
/	%	&amp;
|	~	!
=	&lt;	&gt;
+=	-=	*=
/=	%=	&amp;=
|=	&lt;&lt;	&gt;&gt;
&gt;&gt;=	&lt;&lt;=	==
!=	&lt;=	&gt;=
&amp;&amp;	||	++
--	,	-&gt;*
-&gt;	()	[]	
new	delete	
new[]	delete[]
</code></pre><h2 id="introducing-friends">Introducing Friends</h2>
<p>C++ provides another form of access the private portion of a class object: the <code>friend</code>. Friend comes in three varieties:</p>
<ul>
<li>Friend functions</li>
<li>Friend classes</li>
<li>Friend member functions</li>
</ul>
<p>With the nonmember overloaded operator function, the left operand of an operator expression corresponds to the first argument of the operator function, and the right operand corresponds to the second argument. Using a nonmember function(<code>friend function</code>) solves the problem of getting the operands in the desired order.</p>
<h3 id="creating-friends">creating Friends</h3>
<p>The first step toward creating a friend function is to place a prototype in the class declaration and prefix the declaration with the keyword <code>friend</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">friend</span> Time <span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span>(<span style="color:#66d9ef">double</span> m, <span style="color:#66d9ef">const</span> Time <span style="color:#f92672">&amp;</span> t);	<span style="color:#75715e">// goes into class declaration
</span></code></pre></div><p>This prototype has two implications:</p>
<ul>
<li>Althrough the operator*() function is declared in the class declaration, it is not a member function. So it isn&rsquo;t invoked by using the membership operator.</li>
<li>Althrough the operator*() function isn&rsquo;t a member function, it has the same access rights as a member function.</li>
</ul>
<p>The second step is to write the function definition. Because it is not a member function, you don&rsquo;t use the <code>Time::</code> qualifier. Also you don&rsquo;t use the <code>friend</code> keyword in the definition. For instance:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">Time <span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span>(<span style="color:#66d9ef">double</span> m, <span style="color:#66d9ef">const</span> Time <span style="color:#f92672">&amp;</span> t)	<span style="color:#75715e">//friend not used in definition
</span></code></pre></div><h3 id="a-common-kind-of-friend-overloading-the--operator">A Common Kind of Friend: Overloading the <code>&lt;&lt;</code> Operator</h3>
<p>One of the most common tasks for operator overloading is defining the <code>&lt;&lt;</code> operator so that it can be used in conjunction with the <code>cout</code> object to display an object&rsquo;s contents.
In general, to overload the &laquo; operator to display an object of class <code>c_name</code>, you use a friend function with a definition in this form:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">ostream <span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;&lt;</span>(ostream <span style="color:#f92672">&amp;</span> os, <span style="color:#66d9ef">const</span> c_name <span style="color:#f92672">&amp;</span> obj)
{
	os <span style="color:#f92672">&lt;&lt;</span> ...;	<span style="color:#75715e">// display object content
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> os;
}
</code></pre></div><h3 id="multiple-representation-and-classes">Multiple Representation and Classes</h3>
<p>Quantities that have different, but equivalent, representations are common.</p>
<ul>
<li>First, you can store multiple representations in one object.</li>
<li>Second, you can write the class function so that assigning values for one representation automatically assigns values for the other representation(s).</li>
</ul>
<h3 id="overloading-arithmetic-operators">Overloading Arithmetic Operators</h3>
<p><em><strong>Tip:</strong></em></p>
<p>If a method needs to compute a new class object, you should see if you can use a class constructor to do the work. Not only does that save you trouble, it ensures that the new object is constructed in the proper fashion.</p>
<p><em><strong>Note:</strong></em>
Because operator overloading is implemented with functions, you can overload the same operator many times, as long as each operator function has a distinct signature and as long as each operator function has the same number of operands as the corresponding built-in C++ operator.</p>
<h2 id="automatic-conversiona-and-type-casts-for-classes">Automatic Conversiona and Type Casts for Classes</h2>
<p>You may define a class suffciently related to a basic type or another class that it makes sense to convert from one form to another. In such a case, you can tell C++ how to make such conversions automatically.</p>
<p><em><strong>Note:</strong></em> A C++ constructor that contains one argument defines a type conversion from the argument type to the class type. If the constructor is qualified with the keyword <code>explicit</code>, the constructor is used for explicit conversion only; otherwise, it is also used for implicit conversation.</p>
<p>When does the compiler use the <code>Stonewt(double)</code> function? If the keyword <code>explicit</code> is used in the declaration, <code>Stonewt(double)</code> is used only for an explicit type cast; otherwise, it is also used for the following implicit conversions:</p>
<ul>
<li>When you initialize a <code>Stonewt</code> object to a type <code>double</code> value.</li>
<li>When you assign a type <code>double</code> value to a <code>Stonewt</code> object</li>
<li>Whe you pass a type <code>double</code> value to a function that expects a <code>Stonewt</code> argument.</li>
<li>When a function that&rsquo;s declared to return a <code>Stonewt</code> value tries to return a <code>double</code> value.</li>
<li>When any of the preceding situations use a built-in type that can unambiguously be converted to type <code>double</code>.</li>
</ul>
<p><em><strong>Note:</strong></em> Note that when a constructor has a single argument, you can use the following form when initializing a class object:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// a syntax for initializing a class object when
</span><span style="color:#75715e">// using a constructor with one argument
</span><span style="color:#75715e"></span>Stonewt incognito<span style="color:#f92672">=</span><span style="color:#ae81ff">275</span>;
</code></pre></div><p>This is equivalent to the other two forms shown earlier:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// standard syntax forms for initializing class objects
</span><span style="color:#75715e"></span>Stonewt <span style="color:#a6e22e">incognito</span>(<span style="color:#ae81ff">275</span>);
Stonewt incognito<span style="color:#f92672">=</span>Stonewt(<span style="color:#ae81ff">275</span>);
</code></pre></div><p>However, the last forms can also be used with constructors that have multiple arguments.</p>
<h3 id="conversion-function">Conversion Function</h3>
<p>Constructors only provide for converting another type to the class type. To do the reverse, you have to use a special form of C++ operator function called a <code>conversion function</code>.
So how do you create a conversion function? To convert to type <code>typename</code>, you use a conversion function in this form:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">typename</span>()
</code></pre></div><p>Note the following points:</p>
<ul>
<li>The conversion function must be a class method.</li>
<li>The conversion function must not specify a return type</li>
<li>The conversion function must have no arguments.</li>
</ul>
<p>For example, a function to convert to type double would have this prototype:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">double</span>()
</code></pre></div><p><em><strong>Caution:</strong></em></p>
<p>You should use implicit conversion functions with care. Often a function that can only be invoked explicitly is the best choice. A conversion function must be a member function.</p>
<p>C++ provides the following type conversions for classes:</p>
<ul>
<li>A class constructor that has but a single argument serves as an instruction for converting a value of the argument type to the class type.</li>
<li>A special class member operator function called <code>conversion function</code> serves as an instruction for converting a class object to some other type.</li>
</ul>
<h2 id="about-returning-objects">About Returning Objects</h2>
<h3 id="returning-reference-to-a-const-object">Returning Reference to a <code>const</code> Object</h3>
<p>The usual reason for using a <code>const reference</code> is efficiency, but there are restrictions on when this choice can be used. If a function returns an object that is passed to it, either by object invocation or as a method argument, you can increase the effiency of the method by having it return a reference.</p>
<h3 id="returning-a-reference-to-a-non-const-object">Returning a Reference to a <code>Non-const</code> Object</h3>
<p>Two common example of returning a non-const object are overloading the assignment operator and overloading the &laquo; operator for use with cout. The first is done for reasons of effiency, and the second for reasons of necessity.</p>
<h3 id="returning-an-object">Returning an Object</h3>
<p>If the object being returned is local to the called function, then it should not be returned by reference because the local object has its destructor called when the function terminated. Thus, when control returns to the calling function, there is no object left to which the reference can refer. In these circumstances, you should return an object, not a reference. Typically, overloaded arithmetic operator fall into this category.</p>
<h3 id="returning-a-const-object">Returning a <code>const</code> Object</h3>
<h2 id="using-pointers-to-objects">Using Pointers to Objects</h2>
<p><em><strong>Object Initialization with new:</strong></em></p>
<p>In general, if <code>Class_name</code> is a class and if <code>value</code> is of type <code>Type name</code>, the statement</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">Class_name <span style="color:#f92672">*</span> pclass <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Class_name(value);
</code></pre></div><p>invokes this constructor:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">Class_name(Type_name);
</code></pre></div><p>there may be trivial conversion, such as to this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">Class_name(<span style="color:#66d9ef">const</span> Type_name <span style="color:#f92672">&amp;</span>);
</code></pre></div><p>Also the usual conversions incoked by prototype matching, such as from <code>int</code> to <code>double</code>, takes place as long as there is no ambiguity. An initialization in the following form invokes the default constructor:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">Class_name <span style="color:#f92672">*</span> ptr<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> class_name;
</code></pre></div>
        </div>
        <div class="article-info">
    
        <div class="article-date">2020-05-19</div>
    
    <div class="article-taxonomies">
        
            
                <ul class="article-tags">
                    
                        <li><a href="https://binghuacheng.github.io/tags/c&#43;&#43;-primer-plus">#C&#43;&#43;-Primer-Plus</a></li>
                    
                        <li><a href="https://binghuacheng.github.io/tags/c&#43;&#43;">#C&#43;&#43;</a></li>
                    
                </ul>
        
    </div>
</div>

    </article>
    


        </main>
        <footer>
            
                <p>© binghuacheng, 2020<br>
Powered by <a target="_blank" href="https://gohugo.io/">Hugo</a>, theme <a target="_blank" href="https://github.com/mitrichius/hugo-theme-anubis">Anubis</a>.
</p>
            
        </footer>
    </div>
</body>
</html>
