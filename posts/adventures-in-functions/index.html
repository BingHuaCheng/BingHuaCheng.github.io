<!DOCTYPE html>
<html lang="zh-ch">
<head>
    
        
<meta charset="utf-8">
<meta name="HandheldFriendly" content="True">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer-when-downgrade">

<title>Adventures in Functions  - To be a sailor</title>
<meta name="description" content="books review, life, messy thinking">

<link rel="icon" type="image/x-icon" href="https://binghuacheng.github.io/favicon.ico">
<link rel="apple-touch-icon-precomposed" href="https://binghuacheng.github.io/favicon.png">

<link rel="stylesheet" href="https://binghuacheng.github.io/css/style.css?rnd=1589639888" />



<meta property="og:title" content="Adventures in Functions" />
<meta property="og:description" content="C&#43;&#43; Inline Functions In an inline function，the compiled code is &ldquo;in line&rdquo; with the the other code in the program. With inline code，the program doesn&rsquo;t have to jump to another location to execute the code and jump back. Inline function thus run a little faster than regular function， but they come with a memory penalty（n.惩罚）. If a program calls an inline function at ten separate locations，then the program winds up with ten copies of the function inserted into the code." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://binghuacheng.github.io/posts/adventures-in-functions/" />
<meta property="article:published_time" content="2020-05-12T04:53:49+00:00" />
<meta property="article:modified_time" content="2020-05-12T04:53:49+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Adventures in Functions"/>
<meta name="twitter:description" content="C&#43;&#43; Inline Functions In an inline function，the compiled code is &ldquo;in line&rdquo; with the the other code in the program. With inline code，the program doesn&rsquo;t have to jump to another location to execute the code and jump back. Inline function thus run a little faster than regular function， but they come with a memory penalty（n.惩罚）. If a program calls an inline function at ten separate locations，then the program winds up with ten copies of the function inserted into the code."/>






    
</head>
<body>
    <a class="skip-main" href="#main">Skip to main content</a>
    <div class="container">
        <header> 
            
                <h1 class="site-header">
    <a href="https://binghuacheng.github.io">To be a sailor</a>
</h1>
<nav>
    
    
    <a class="" href="/about/" title="">About</a>
    
    <a class="" href="/tags/" title="">Tags</a>
    
    <a class="" href="/posts/" title="">Archive</a>
    
</nav>

            
        </header>
        <main id="main" tabindex="-1"> 
            

    <article class="post">
        <header>
            <h1>Adventures in Functions</h1>
        </header>
        <div class="content">
            <h2 id="c-inline-functions">C++ Inline Functions</h2>
<p>In an inline function，the compiled code is &ldquo;in line&rdquo; with the the other code in the program. With inline code，the program doesn&rsquo;t have to jump to another location to execute the code and jump back. Inline function thus run a little faster than regular function， but they come with a memory penalty（n.惩罚）. If a program calls an inline function at ten separate locations，then the program winds up with ten copies of the function inserted into the code.</p>
<p>To use the Inline function，you must take at least one of two actions:</p>
<ul>
<li>Preface the functio <code>declaration</code> with the keyword <code>inline</code>.</li>
<li>Preface the function <code>definition</code> with the keyword <code>inline</code></li>
</ul>
<p>A common practice is to omit the prototype and to place the entire definition where the prototype would normally go.</p>
<p><strong>Note:</strong> If the function is too larger or calls itself， don&rsquo;t use inline function.</p>
<h2 id="reference-variables">Reference Variables</h2>
<p>A <em>reference</em> is a name that acts as an alias，or an alternative name，for a <strong>previously defined</strong> variable.</p>
<p>The main use for a reference variable is as a formal argument to a function. If you use a reference as a argument，the function works with the original data instead of with a copy.</p>
<h3 id="creating-a-reference-variable">Creating a Reference Variable</h3>
<p>C and C++ use the &amp; symbol to indicate the address of a variable，however C++ assigns an additional meaning to the &amp; symbol and presses it into service for declaring references. For example，to make <em>rodents</em> an alternative name for variable <em>rats</em>，you could do the following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> rats;
<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span> rodents <span style="color:#f92672">=</span> rats <span style="color:#75715e">// makes rodents an alias for rats 
</span></code></pre></div><p>Just as char * in a declaration means pointer-to-char，int &amp; means reference-to-int. The reference declaration allows you to use <em>rats</em> and <em>rodents</em> interchangeably; both refer to the same value and the same momory location.</p>
<p><em><strong>Note:</strong></em> You should initialize a reference variable when you declare it.</p>
<p>A reference is rather like a <strong>const</strong> pointer; you have to initialize it when you create it，and when a reference pledges(v. 保证，许诺）its allegiance to a particular variable，it stick to its pledge. That is，
int &amp; rodents=rats;
is，in essence，a disguised notation for something like this:
int * const pr=&amp;rats;
Here，the reference <em>rodents</em> play the same role as the express *pr.</p>
<p>Suppose you tried the following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> rats<span style="color:#f92672">=</span><span style="color:#ae81ff">101</span>;
<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span> pt <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>rats;
<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>rodents <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>pt;
<span style="color:#66d9ef">int</span> bunnies <span style="color:#f92672">=</span> <span style="color:#ae81ff">50</span>;
pt <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>bunnies;
</code></pre></div><p>Initializing rodents to *pt makes rodents refer to rats. Subsequently altering pt to point to bunnies does not alter the fact that rodents refers to rats.</p>
<h3 id="references-as-function-parameters">References as Function Parameters</h3>
<p>Most often，references are used as function parameters, making a variable in a function an alias for a variable in the calling program. This method of passing arguments is called <em><strong>passing by reference</strong></em>. Passing by reference allows a called function to access variable in the calling function. For instance:
swapr.cpp</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swapr</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span> a, <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span> b);

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
	<span style="color:#66d9ef">int</span> wallet1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">300</span>;
	<span style="color:#66d9ef">int</span> wallet2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">350</span>;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;wallet1 = $&#34;</span> <span style="color:#f92672">&lt;&lt;</span> wallet1;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;wallet2 = $&#34;</span> <span style="color:#f92672">&lt;&lt;</span> wallet2; 
		<span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Using references to swap contents:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
	swapr(wallet1<span style="color:#960050;background-color:#1e0010">，</span>wallet2);
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;wallet1 = $&#34;</span> <span style="color:#f92672">&lt;&lt;</span> wallet1;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;wallet2 = $&#34;</span> <span style="color:#f92672">&lt;&lt;</span> wallet2 <span style="color:#f92672">&lt;&lt;</span> endl;

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swapr</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span> a, <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span> b)
{
	<span style="color:#66d9ef">int</span> temp;

	temp<span style="color:#f92672">=</span>a;
	a<span style="color:#f92672">=</span>b;
	b<span style="color:#f92672">=</span>temp;
}
</code></pre></div><p><em><strong>Note:</strong></em> A function call initializes its parameters with argument values from the function call. So reference function arguments are initialized to the argument passed by the function call.</p>
<h3 id="reference-properties-and-oddities">Reference Properties and Oddities</h3>
<p>If your intent is that a function use the information passed to it without modifying the information, and if you&rsquo;re using a reference, you should use aa constant reference. Here, for example, you should use <em>const</em> in the function prototype and function header:
double cube(const double &amp;r)</p>
<h4 id="temporary-variables-references-arguments-and-const">Temporary Variables, References Arguments, and <em>const</em></h4>
<p>C++ can generate a tempolary variable if the actual argument doesn&rsquo;t match a reference argument. Currently, C++ permits this only if the argument is a const reference.</p>
<p>Provided that the reference parameter is a <em>const</em>, the compiler generates a temporary variable in two kinds of situations:</p>
<ul>
<li>When the actual argument is the correct type but isn&rsquo;t an lvalue</li>
<li>When the actual argument is of the wrong type, but it&rsquo;s of a type that can be converted to the correct type.</li>
</ul>
<p>Both a regular variable abd a const variable would be considered lvalues because both can accessed by address. But the regular variable can be further characterized as being a <em>modifiable lvalue</em> and the const variable as a <em>non-modifiable lvalue</em>.</p>
<p>If the intent of a function with argument is to modify variables passed as arggument, situation that create temporary variables thwart that purpose. The solution is to prohibit creating temporary variables in these situation.</p>
<p><em><strong>Note:</strong></em></p>
<p>If a function call argument isn&rsquo;t an <em>lvalue</em> or doesn&rsquo;t match the type of the corresponding <em>const</em> reference parameter, C++ creates an anonymous variable of the correct type, assigns the value of the function call argument to the annoymous variable, and has the parameter refer to that variable.</p>
<p><em><strong>Use const when you can</strong></em></p>
<p>There are three strong reason to declare reference arguments as references to the constant data:</p>
<ul>
<li>Using <strong>const</strong> protects you against programming errors that  inadvertently alter data.</li>
<li>Using <strong>const</strong> allows a function to process both <strong>const</strong> and <strong>non-const</strong> actual argguments, whereas a function that omits <strong>const</strong> in the prototype only can accept non-const data.</li>
<li>Using a const reference allows the function to generate and use a temporary variable appropriately.</li>
</ul>
<p>C++11 introduces a second kind of reference, called an <strong>rvalue reference</strong>, that can reference to an rvalue.</p>
<h3 id="using-references-with-a-structure">Using References with a Structure</h3>
<p>References work wonderfully with structures and classes, C++'s user-defined types. Indeed, references were introduced primarily for use with these types, not for use with the basic built-in types.</p>
<h4 id="why-return-a--reference">Why Return a  Reference?</h4>
<p>Now consider this statement:</p>
<pre><code> dup=accumulate(team, five);
</code></pre>
<h2 id="a-function-that-returns-a-reference-is-actually-an-alias-for-the-referred-to-variable">If accumulate() returned a structure instead of a reference to a structure, this could involve copying the entire structure to a temporary location  and then copying that copy to dup. But with a reference return value, team is copied directly to dup, a  more efficient approach.
<em><strong>Note:</strong></em>
<code>A function that returns a reference is actually an alias for the referred-to variable.</code></h2>
<h4 id="being-careful-about-what-a-return-reference-refers-to">Being Careful About What a Return Reference Refers To</h4>
<p>The single most important point to remember when returning a reference is to  avoid returning a reference to a memory location that ceases to exist when the function terminates. What you want to avoide is code along these lines:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">const</span> free_throws <span style="color:#f92672">&amp;</span> clone2(free_throws <span style="color:#f92672">&amp;</span> ft)
{
	free_throws newguy;
	newguy<span style="color:#f92672">=</span>ft;
	<span style="color:#66d9ef">return</span> newguy;
}
This has the unfortunate effect of returning a reference to a temporary variable(newguy) that passes from existence as soon as the function terminates. Similarly, you should avoid returning pointers to such temporary variables.
<span style="color:#f92672">*</span> The simple way to avoid this problem is to <span style="color:#66d9ef">return</span> a reference that was passed as an argument to the function. A reference parameter will refer to data used by the calling function; hence, the returned reference will refer to the same data.
<span style="color:#f92672">*</span> A second method is to use new to create new storage.
<span style="color:#f92672">---</span>
<span style="color:#75715e">#### Why Use const with a Reference Return?
</span><span style="color:#75715e"></span>Suppose you want to use a reference <span style="color:#66d9ef">return</span> value but don<span style="color:#960050;background-color:#1e0010">&#39;</span>t want to permit such as assigning a value to accumulate(). Just make the <span style="color:#66d9ef">return</span> type a <span style="color:#66d9ef">const</span> reference:
<span style="color:#960050;background-color:#1e0010">```</span>c<span style="color:#f92672">++</span>
<span style="color:#66d9ef">const</span> free_throws <span style="color:#f92672">&amp;</span>
	accumulate(free_throws <span style="color:#f92672">&amp;</span> target, <span style="color:#66d9ef">const</span> free_throws <span style="color:#f92672">&amp;</span> source);
</code></pre></div><p>The return type now is const, hence a nonmodifiable lvalue. Therefore, the assignment no longer is allowed:
accumulate(dup, five)=four; // not allowed for const reference return</p>
<h3 id="using-references-with-a-class-object">Using References with a class Object</h3>
<p>The usual C++ practice for passing class objects to a function is to use references. For instance, you would use reference parrameters for functions taking objects of the <em><strong>string, ostream, istream, ofstream</strong></em>, and <em><strong>ifstream</strong></em> classes as arguments.</p>
<hr>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">string <span style="color:#a6e22e">version1</span>(<span style="color:#66d9ef">const</span> string <span style="color:#f92672">&amp;</span> s1, <span style="color:#66d9ef">const</span> string <span style="color:#f92672">&amp;</span> s2)
{
	string temp;
	temp<span style="color:#f92672">=</span>s2<span style="color:#f92672">+</span>s1<span style="color:#f92672">+</span>s2;
	<span style="color:#66d9ef">return</span> temp;
}
</code></pre></div><h2 id="the-temp-object-is-a-new-object-local-to-the-version1-function-and-it-ceases-to-exist-when-the-function-terminates-thus-returning-temp-as-a-reference-wont-work-so-the-function-type-is-string">The <em><strong>temp</strong></em> object is a new object, local to the version1() function, and it ceases to exist when the function terminates. Thus, returning temp as a reference won&rsquo;t work, so the function type is string.</h2>
<p><em><strong>Passing a C-style String Argument to a string Object Reference Parameter:</strong></em></p>
<p>You may have noticed a rather interesting fact about the version1() function: Both formal parameters(s1 and s2) are type <em><strong>const string &amp;</strong></em>, but the actual arguments(input and &ldquo;***&quot;) are type string and const char *, respectively. Because input is type string, there is no problem having s1 refer to it. But how is it that the program accepts passing a pointer-to-char argument to a string reference?
Two things are going on here. One is that the string class defines a char *-to-string conversion, which makes it possible to initialize a string object to a C-style string. The second is a property of const reference formal parameters that is discussed earlier in this charpter. Suppose the actual argument type doesn&rsquo;t match the reference parameter type but can be converted to the reference type. Then the program creates a temporay variable of the correct type, initialize it to the converted value, and passes a reference to the temporary variable. Earlier this character you saw, for instance, that a const douuble &amp; parameter can handle an int arggument in this fashion. Similarly, a const string &amp; pparameter can handle a char * or const char * argument in this fashion.
The convenient outcome of this is that if the formal parameter is type const string &amp;, the actual argument used in the function call can be a string object or a C-style string, such as a quoted string literal, a null-terminated array of char, or a pointer variable that points to a char.</p>
<h3 id="another-object-lesson-objects-inheritance-and-references">Another Object Lesson: Objects, Inheritance, and References</h3>
<p>A derived class inherits the base class methods, which means that an <em><strong>ofstream</strong></em>  object can use base class features such as the precision() and setf() formatting methods.
Another aspect of inheritance is that a base reference can refer to a derived class object without requiring a type cast.</p>
<h3 id="when-to-use-reference-arguments">When to Use Reference Arguments</h3>
<p>There are two main reasons for using reference arguments:</p>
<ul>
<li>To allow you to alter a data object in the calling function</li>
<li>To speed up a program by passing a reference instead of an entire data object.</li>
</ul>
<p>There are some guidelines about when you should use a reference, a pointer and pass by value:
1.A function uses passed data without modifying it:</p>
<ul>
<li>If the data object is small, such as a built-in data type or a small structure, pass it by value.</li>
<li>If the data object is a good-sized structure, use a const pointer or a const reference to increase program effiency. You save the time and space needed to copy a structure or a class design. Make the pointer or reference const.</li>
<li>If the data object is an array, use a pointer because that&rsquo;s your only choice. Make the pointer a pointer to const.</li>
<li>If the data object is a class object, use a const reference. The semantics of class design often require using a reference, which is the main reason C++ added this feature. Thus, the standard way to pass class object arguments is by reference.</li>
</ul>
<p>2.A function modifies data in the calling function:</p>
<ul>
<li>If the data object is built-in data type, use a pointer. If you spot code like fixit(&amp;x), where x is an int, it&rsquo;s very pretty clear that this function intends to modify x.</li>
<li>If the datya object is an array, use your only choice: a poiter.</li>
<li>If the data object is a structure, use a reference or a pointer.</li>
<li>If the data object is a class object, use a reference.</li>
</ul>
<h2 id="default-arguments">Default Arguments</h2>
<p>A <em>default argument</em> is a value that&rsquo;s used automatically if you omit the corresponding actual argument from a function call.
When you use a function with an argument list, you must add defaults from right to left. That is, you can&rsquo;t provide a default value for a particular argument unless you also provide defaults for the arguments to its right:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">harpo</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> m, <span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>);	<span style="color:#75715e">// valid
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">chico</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> m<span style="color:#f92672">=</span><span style="color:#ae81ff">6</span>, <span style="color:#66d9ef">int</span> j);	<span style="color:#75715e">// invalid
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">groucho</span>(<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">int</span> m<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">int</span> n<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>);	<span style="color:#75715e">// valid
</span></code></pre></div><p>Note that only the prototype indicates the default. The function definition is the same as it would be without default arguments.</p>
<h2 id="fucntion-overloading">Fucntion Overloading</h2>
<p>Function polymorphism is a neat C++ addition to C&rsquo;s capabilities. Whereas default arguments lets you call the same function by using varing numbers of arguments, function polymorphism, also called function overloading, lets you use multiple function sharing the same name. The word polymorphism means having many forms, so function polymorphism lets a function have many forms. Similarly, the expression function overloading means you can attach more than one function to the same name, thus overloading the name. Both expressions boils down to the same thing, but we&rsquo;ll  usually use the expression function overloading. You can use function overloading to design a family of functions that do essentially the same thing but using different argument lists.</p>
<p>The key to function overloading is function&rsquo;s argument list, also called the <strong>function signature.</strong> If two function use the same number and types of arguments in the same order, they have the same signature; the variable names don&rsquo;t matter. C++ enables you to define two functions by the same name, providede that the functions have different signatures. The signature can differ in the <strong>number</strong> of arguments or in the <strong>type</strong> of arguments, or both.</p>
<p>When yyou use overloaded functions, you need to be sure you use the proper argument types in the function call.</p>
<p>Note some signatures that appear to be different from each other nonetheless can&rsquo;t coexist, for example, consider these two prototypes:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">double</span> <span style="color:#a6e22e">cube</span>(<span style="color:#66d9ef">double</span> x);
<span style="color:#66d9ef">double</span> <span style="color:#a6e22e">cube</span>(<span style="color:#66d9ef">double</span> <span style="color:#f92672">&amp;</span> x);
</code></pre></div><p>When the compiler checks function signatures, it considers a reference to a type and the type itself to be the same signature.</p>
<p>The function-matching process does discriminate between const and non-const variable. Consider the following prototypes:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dabble</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> bits);
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">drivel</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> bits);
</code></pre></div><p>The dabble() function only matches a call with a non-const argument, but the drivel() function matches calls with either const or non-const arguments. The reason for this difference in behavior between drivel() and dabble() is that it&rsquo;s valid to assign a non-const value to a const variable, but not vice versa.</p>
<p>Keep in mind that the signature, not the function type, enables function overloading. For example, the following two declarations are incompatible:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">gronk</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">float</span> m);	<span style="color:#75715e">//same signatures,
</span><span style="color:#75715e"></span><span style="color:#66d9ef">double</span> <span style="color:#a6e22e">gronk</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">float</span> m);	<span style="color:#75715e">// hence not allowed
</span></code></pre></div><p><em><strong>Overloading Reference Parameters</strong></em>:</p>
<p>Class designs and the STL often use reference parameters, and it&rsquo;s useful to know how overloading works with different reference types. Consider the following three prototypes:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sink</span>(<span style="color:#66d9ef">double</span> <span style="color:#f92672">&amp;</span> r1);	<span style="color:#75715e">//matches modifiable lvalue
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sank</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">double</span> <span style="color:#f92672">&amp;</span> r2);	<span style="color:#75715e">//matches modifiable or const lvalue, rvalue
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sunk</span>(<span style="color:#66d9ef">double</span> <span style="color:#f92672">&amp;&amp;</span> r3);	<span style="color:#75715e">//matches rvalue
</span></code></pre></div><p>The lvalue reference parameter r1 matches a modifiable lvalue argument, such as a double variable. The const lvalue reference parameter r2 mattches a modifiable lvalue argument, a const lvalue argument, and an rvalue argument, such as the sum of two double values. Finally, the rvalue reference r3 matches an rvalue. Note how r2 can match the same sort of arguments that r1 and r3 match. This raises the question of what happens when you overload a function on these three types of parameters. <strong>The answer is that the more exact match is made:</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">staff</span>(<span style="color:#66d9ef">double</span> <span style="color:#f92672">&amp;</span> rs);	<span style="color:#75715e">//matches modifiable lvalue
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">staff</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">double</span> <span style="color:#f92672">&amp;</span> rcs);	<span style="color:#75715e">//matches rvalue, const lvalue
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">stove</span>(<span style="color:#66d9ef">double</span> <span style="color:#f92672">&amp;</span> r1);	<span style="color:#75715e">//matches modifiable lvalue
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">stove</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">double</span> <span style="color:#f92672">&amp;</span> r2);	<span style="color:#75715e">//matches const lvalue
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">stove</span>(<span style="color:#66d9ef">double</span> <span style="color:#f92672">&amp;&amp;</span> r3);	<span style="color:#75715e">//matches rvalue
</span></code></pre></div><h2 id="function-template">Function Template</h2>
<p>A function template is a generic function description; that is, it defines a function in terms of a generic type for which a specific type, such as int or double, can be substituded. By passing a type as a parameter to a template, you cause the compiler to genarate a function for that particular type. Because templates let you program in terms of a generic type instead of a specific type, the process is sometimes termed generic programming. Because types are represented by parameters, the template feature is sometimes referred to as <strong>parameterized types</strong>.
Function templates enable you to define a function in terms of some arbitrary type. For example, you can set up a swapping template like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> AnyType<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> Swap(AnyType <span style="color:#f92672">&amp;</span>a, Anytype <span style="color:#f92672">&amp;</span>b)
{
	Anytype temp;
	temp<span style="color:#f92672">=</span>a;
	a<span style="color:#f92672">=</span>b;
	b<span style="color:#f92672">=</span>temp;
}
</code></pre></div><p>The keywords template and typename are obligatory, except that you can use the keyword class instead of typename. Also you must use the angle brackets. The template does not create any function. Instead, it provides the compiler with direction about how to define a function.
Before the C++98 Standard added the keyword typename to the language, C++ used the keyword class in this pariticular context. That is, you can write the template definition this way:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AnyType</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> Swap(AnyType <span style="color:#f92672">&amp;</span>a, AnyType <span style="color:#f92672">&amp;</span>b)
{
	AnyType temp;
	temp<span style="color:#f92672">=</span>a;
	a<span style="color:#f92672">=</span>b;
	b<span style="color:#f92672">=</span>temp;
}
</code></pre></div><p>The C++ Standard treats the two keywords identically when they are used in this context.
<em><strong>Tip:</strong></em></p>
<p>You should use templates if you need functions that apply the same algorithm to a variety of types. If you aren&rsquo;t concerned with backward compatibility and can put up with the effort of typing a longer word, you can use the keyword typename rather than class when you declare type parameter.</p>
<h3 id="overloaded-templates">Overloaded Templates</h3>
<p>You use template when you need functions that apply the same algorithm to a variety of types.However, that not all types would use the same algorithm. To handle this possibility, you can overload template definitions. For instance:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//twotemps.cpp -- using overloaded template functions
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>	<span style="color:#75715e">// original template
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> Swap(T <span style="color:#f92672">&amp;</span>a, T <span style="color:#f92672">&amp;</span>b);

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>	<span style="color:#75715e">// new template
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> Swap(T <span style="color:#f92672">*</span>a, T <span style="color:#f92672">*</span>b, <span style="color:#66d9ef">int</span> n);
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	...
	...
}

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> Swap(T <span style="color:#f92672">&amp;</span>a, T <span style="color:#f92672">&amp;</span>b)
{
	T temp;
	temp<span style="color:#f92672">=</span>a;
	a<span style="color:#f92672">=</span>b;
	b<span style="color:#f92672">=</span>temp;
}

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> Swap(T a[], T b[], <span style="color:#66d9ef">int</span> n)
{
	T temp;
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>n; i<span style="color:#f92672">++</span>)
	{
		temp<span style="color:#f92672">=</span>a[i];
		a[i]<span style="color:#f92672">=</span>b[i];
		b[i]<span style="color:#f92672">=</span>temp;
	}
}
</code></pre></div><h4 id="explicit-specializations">Explicit Specializations</h4>
<p>If the compiler finds a specified difinition that exactly matches a function call, it uses that definition without looking for templates.</p>
<h5 id="third-generation-specializationisoansi-c-standard">Third-Generation Specialization(ISO/ANSI C++ Standard)</h5>
<p>After some experimentation with other approach, the C++98 Standard setted on this approach:</p>
<ul>
<li>For a given function name, you can have a non template function, a template function, and an explicit specification template function, along with overloaded versions of all of these.</li>
<li>The prototype and definition for an explicit specialication shoud be proceded by template &lt;&gt; and should mention the specialized type by name.</li>
<li>A specialization overrides the regular template, and a non template function overrides both.</li>
</ul>
<p>Here&rsquo;s how prototypes for swapping type job structures would look for these forms:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// non template function prototype
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Swap</span>(job <span style="color:#f92672">&amp;</span>, job <span style="color:#f92672">&amp;</span>);

<span style="color:#75715e">// template prototype
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> Swap(T <span style="color:#f92672">&amp;</span>, T <span style="color:#f92672">&amp;</span>);

<span style="color:#75715e">// explicit specialization for the job type
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;&gt;</span> <span style="color:#66d9ef">void</span> Swap<span style="color:#f92672">&lt;</span>job<span style="color:#f92672">&gt;</span>(job <span style="color:#f92672">&amp;</span>, job <span style="color:#f92672">&amp;</span>);
</code></pre></div><p>Note: Non template version &gt; Explicit specialization version &gt; template version</p>
<p>In addition, the <!-- raw HTML omitted --> in Swap(job) is optional because the function argument types indicates that this is a secification for job. Thus, the prototype can be written this way:</p>
<pre><code>template &lt;&gt; void Swap(job &amp;, job &amp;);
</code></pre><h4 id="instantiations-and-specializations">Instantiations and specializations</h4>
<p>Keep in mind that including a function template in you code does not in itself generate a function definition. It&rsquo;s merely a plan for generating a function definition for a particular type, the result is termed an instantiation of the template. The template is not a function definition, but the specific instantiation using int is a function definition. This type of instantiation is termed implicit instantiation because the compiler deduces the necessity for making the definition by noting that the program uses a Swap() function with int paramaters. However, now C++ allows for explicit instantiation. That means you can instruct the compiler to create a particular instantiation &ndash; for example, Swap<!-- raw HTML omitted -->() &ndash; directly. The syntax is to declare the particular variety you want, using the &lt;&gt; notation to indicate the type and prefixing the declaration with the keyword template:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span> <span style="color:#66d9ef">void</span> Swap<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>);  <span style="color:#75715e">//explicit instantiation
</span></code></pre></div><hr>
<pre><code>template &lt;&gt; void Swap&lt;int&gt;(int &amp;, int &amp;);	//explicit specialization
template &lt;&gt; void Swap(int &amp;, int &amp;);	//explicit specialization
</code></pre><p>The explicit specialization declaration has &lt;&gt; after the keyword termplate, whereas the explicit instantiation omits the &lt;&gt;.</p>
<p>**Caution:**It is an error to try to use both an explicit instantiation and an explicit specialization for the same type(s) in the same file, or, more generally, the same translation unit.</p>
<p>Implicit instantiations, explicit instantiations, and explicit specializations collectively are termed <em>specializations</em>. What they all have in common is that they represent a function definition that uses specific types rather than one that is a generic description.
The following fragment summaries the main concept:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">...
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> Swap(T <span style="color:#f92672">&amp;</span>, T <span style="color:#f92672">&amp;</span>);	<span style="color:#75715e">// template prototype
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;&gt;</span> <span style="color:#66d9ef">void</span> Swap<span style="color:#f92672">&lt;</span>job<span style="color:#f92672">&gt;</span>(job <span style="color:#f92672">&amp;</span>, job <span style="color:#f92672">&amp;</span>);	<span style="color:#75715e">// explicit specialization for job
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
	<span style="color:#66d9ef">template</span> <span style="color:#66d9ef">void</span> Swap<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">&amp;</span>, <span style="color:#66d9ef">char</span> <span style="color:#f92672">&amp;</span>);  <span style="color:#75715e">//explicit instantiation for char
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">short</span> a, b;
	...
	Swap(a,b);	<span style="color:#75715e">//implicit template instantiation for short
</span><span style="color:#75715e"></span>	job n, m;
	...
	Swap(n, m);	<span style="color:#75715e">//use explicit specialization for job
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">char</span> g, h;
	...
	Swap(g, h);	<span style="color:#75715e">//use explicit template instantiation for char
</span><span style="color:#75715e"></span>	...
}
</code></pre></div><h3 id="which-function-version-does-the-compiler-pickoverload-resolution">Which Function Version Does the Compiler Pick?(overload resolution)</h3>
<ul>
<li><strong>Phase 1</strong> &ndash; Assemble a list of candidate function. These are functions and template function that have the same names as the called the called functions.</li>
<li><strong>Phase 2</strong> &ndash; From the candidate functions, assemble a list of viable（切实可行的） function. These are functions with the correct number of arguments and for which there is implicit conversion sequence, which includes the case of an exact match of each type of actual argument to the type of the corresponding formal argument. For example, a function call with a type <code>float</code> argument could have that value converted to a <code>double</code> to match a type <code>double</code> formal parameter, and a template could generate an instantiation for <code>float</code>.</li>
<li><strong>Phase 3</strong> &ndash; Determine whether there is a best viable function. If so, you use that function. Otherwise, the function call is an error.</li>
</ul>
<h4 id="extract-matches-an-best-matches">Extract Matches an Best Matches</h4>
<p><em><strong>Trival Conversations Allowed for an Extract Match</strong></em>
| From an Actual Argument | To a Formal Argument|
| &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;	| &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-|
| Type			| Type &amp; 		|
| Type &amp;		| Type			|
| Type []		| * Type		|
| Type(argument-list)	| Type(*)(argument-list	|
| Type			| const Type		|
| Type			| volatile Type		|
| Type *		| const Type *		|
| Type *		| volatile Type *	|</p>
<hr>
<p><em><strong>Note:</strong></em> The overload resolution process look for a function that&rsquo;s the best match. If there&rsquo;s just one, that function is chosen. If more than one are otherwise tied, but only one is a non template, that non template function is chosen. If more than one candidate are otherwise tied and all are  template functions, but one template is more specialized than the rest, that one is chosen. If there are two or more equally good non template functions, or if there are two or more equally good template functions, none is which is more specified than the rest, the function call is ambiguous and an error. If there are non matching calls, of course, that&rsquo;s also an error.</p>
<p><em><strong>Note:</strong></em> As with regular functions, a template function definition can act as its own prototype if it appears before the function is used.</p>
<h3 id="template-function-evolution">Template Function Evolution</h3>
<p>One problem is that when you write a template function, it&rsquo;s not always possible in C++98 to know what type to use in a declaration. Consider this example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T1</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T2</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> ft(T1 x, T2 y)
{
	...
	<span style="color:#f92672">?</span>type<span style="color:#f92672">?</span> xpy<span style="color:#f92672">=</span>x<span style="color:#f92672">+</span>y;
	...
}
</code></pre></div><p>What should the type for xyp be?</p>
<h4 id="the-decltype-keywordc11">The <code>decltype</code> Keyword(C++11)</h4>
<p>The C++11 solution for the above problem is a new keyword:<code>decltype</code>. It can be used in this way:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> x;
<span style="color:#66d9ef">decltype</span>(x) y;	<span style="color:#75715e">// make y the same type as x
</span></code></pre></div><p>The argument to <code>decltype</code> can be an expression, so in the <code>ft()</code> example, wwe could use this code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">decltype</span>(x<span style="color:#f92672">+</span>y) xpy;	<span style="color:#75715e">// make xpy the same as x+y
</span><span style="color:#75715e"></span>xpy<span style="color:#f92672">=</span>x<span style="color:#f92672">+</span>y;
</code></pre></div><p>For the <code>decltype</code> facility, the compiler has to go through a checklist to decide on the type. Suppose we have the following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">decltype</span>(expression) var
</code></pre></div><p>Here are somewhat simplified version of the list:</p>
<ul>
<li>Stage 1: If <code>expression</code> is an unparenthesized identifier(that is, no additional parentheses), then <code>var</code> is of the same type as the identifier, including such as <code>const</code>.</li>
<li>Stage 2: If <code>expression</code> is a function call, then <code>var</code> has the type of the function return type.</li>
<li>Stage 3: If <code>expression</code> is an lvalue, then <code>var</code> is a reference to the expression type.(p440)</li>
<li>Stage 4: If none of the preceding special cases apply, <code>var</code> is of the same type as <code>expression</code></li>
</ul>
<p><strong>Note:</strong> If you need more than one declaration, you can use <code>typedef</code> with <code>decltype</code>, such as</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">decltype</span>(x<span style="color:#f92672">+</span>y) xytype;
xytype xpy<span style="color:#f92672">=</span>x<span style="color:#f92672">+</span>y;
xytype arr[<span style="color:#ae81ff">10</span>];
xytype <span style="color:#f92672">&amp;</span> rxy <span style="color:#f92672">=</span> arr[<span style="color:#ae81ff">2</span>];	<span style="color:#75715e">// rxy a reference
</span></code></pre></div><h4 id="alternative-function-syntaxc11-trailing-return-type">Alternative Function Syntax(C++11 Trailing Return Type)</h4>
<p>Due to the <code>decltype</code> specifier has to come after the parameters are declared, the <code>decltype</code> mechanism by itself leaves another related problem unsolved. Consider this incomplete template function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T1</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T2</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">?</span>type<span style="color:#f92672">?</span> gt(T1 x, T2 y)
{
	...
	<span style="color:#66d9ef">return</span> x<span style="color:#f92672">+</span>y;
}
</code></pre></div><p>Again, we don&rsquo;t know in advance what type results from adding x and y.
C++11 allows a new syntax for declaring and defining functions. Here&rsquo;s how it works using built-in type. The prototype:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">double</span> <span style="color:#a6e22e">h</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">float</span> y);
</code></pre></div><p>can be written with this alternative syntax:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">h</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">float</span> y) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">double</span>;
</code></pre></div><p>The same form could be used with the function definition:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">{<span style="color:#75715e">/* function body*/</span>}
<span style="color:#66d9ef">auto</span> h(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">float</span> y) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">double</span>
</code></pre></div><p>Combining this syntax with <code>decltype</code> leads to the following solution for specifying the return type for <code>gt()</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T1</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T2</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">auto</span> gt(T1 x, T2 y) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">decltype</span>(x<span style="color:#f92672">+</span>y)
{
	...
	<span style="color:#66d9ef">return</span> x<span style="color:#f92672">+</span>y;
}
</code></pre></div><h2 id="summary">Summary</h2>
<p>C++ has expanded C function capabilities. By using an inline keyword with a function definition and by placing that definition ahead of the first call to that function, you suggest to the C++ compiler that it make the function inline. That is, instead of having the program jump to a separate section of code to execute the function, the compiler replaces the function call with the corresponding code inline. An inline facility should be used only when the function is short.
A reference variable is a kind of disguised(伪装的） pointer that lets you create an alias(that is, a second name) for a variable. Reference variables are primarily used as arguments to functions that process structure and class object. Normally, an identifier declared as a reference to a particular type can refer only to data of that type. However, when one class is derived from another, such as <code>ofstream</code> from <code>ostream</code>, a reference to the base type may also refer to the derived type.
C++ prototypes enable you to define default values for arguments. If a function call omits the corresponding argument, the program uses the default value. If a function includes an argument value, the program uses that value instead of the default. Default argument can be provided only from right to left in the argument list. Thus, if you provide a default value for a particular argument, you must also provide default value to the right of that argument.
A function&rsquo;s signature is its argument list. You can define two functions having the same name, provided that they have different signatures. This is called <code>function polymorphism</code>, or <code>function overloading</code>. Typically, you overload functions to provide essentially the same service to different types.
Function templates automate the process of overloading function. You define a function by using a generic type and a particular algorithm, and the compiler generates appropriate function definitions for the particular argument types you use in a program.</p>

        </div>
        <div class="article-info">
    
        <div class="article-date">2020-05-12</div>
    
    <div class="article-taxonomies">
        
            
                <ul class="article-tags">
                    
                        <li><a href="https://binghuacheng.github.io/tags/c&#43;&#43;-primer-plus">#C&#43;&#43;-Primer-Plus</a></li>
                    
                        <li><a href="https://binghuacheng.github.io/tags/c&#43;&#43;">#C&#43;&#43;</a></li>
                    
                </ul>
        
    </div>
</div>

    </article>
    


        </main>
        <footer>
            
                <p>© binghuacheng, 2020<br>
Powered by <a target="_blank" href="https://gohugo.io/">Hugo</a>, theme <a target="_blank" href="https://github.com/mitrichius/hugo-theme-anubis">Anubis</a>.
</p>
            
        </footer>
    </div>
</body>
</html>
